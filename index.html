<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Parabolic HUD Distortion</title>
<style>
    body {
        margin: 0;
        background: #111;
        color: #eee;
        font-family: sans-serif;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 20px;
        padding: 24px;
    }
    h1 {
        margin: 0 0 8px 0;
        font-size: 24px;
        font-weight: 600;
        color: #ddd;
        letter-spacing: 0.5px;
    }
    canvas { 
        border: 1px solid #444;
        max-width: 90vw;
        max-height: 70vh;
        transition: border-color 0.2s;
    }
    canvas.drag-over {
        border-color: #0af;
        border-width: 2px;
    }
    .canvas-container {
        position: relative;
        display: inline-block;
        cursor: pointer;
    }
    .drop-hint {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: #888;
        font-size: 18px;
        pointer-events: none;
        text-align: center;
        transition: opacity 0.3s;
    }
    .drop-hint.hidden {
        opacity: 0;
    }
    .panel {
        display: flex;
        flex-direction: column;
        gap: 18px;
        width: 100%;
        max-width: 400px;
    }
    .control-row {
        display: flex;
        align-items: center;
        gap: 14px;
    }
    .control-row.hidden,
    #downloadBtn.hidden {
        display: none;
    }
    label {
        width: 90px;
        flex-shrink: 0;
    }
    #curvNumber, #scaleNumber {
        width: 70px;
        background: #222;
        color: #eee;
        border: 1px solid #555;
        padding: 4px 6px;
    }
    input[type="range"] {
        flex: 1;
        min-width: 150px;
    }
    #downloadBtn {
        background: #0af;
        color: #fff;
        border: none;
        padding: 6px 12px;
        cursor: pointer;
        border-radius: 4px;
    }
    #downloadBtn:hover {
        background: #09e;
    }
</style>
</head>
<body>
    
<h1>Parabolic Distortion Tool</h1>

<div class="panel">
    <input type="file" id="fileInput" accept="image/*" style="display: none;">

    <div class="control-row hidden" id="curvatureRow">
        <label>Curvature</label>
        <input type="number" id="curvNumber" step="0.001" min="0" max="2" value="0">
        <input type="range" id="curvature" min="0" max="2" step="0.001" value="0">
    </div>

    <div class="control-row hidden" id="scaleRow">
        <label>Scale</label>
        <input type="number" id="scaleNumber" step="0.01" min="0.5" max="1.5" value="1.0">
        <input type="range" id="scale" min="0.5" max="1.5" step="0.01" value="1.0">
    </div>

    <button id="downloadBtn" class="hidden">Download PNG</button>
</div>

<div class="canvas-container">
    <canvas id="glcanvas" width="1024" height="512"></canvas>
    <div class="drop-hint" id="dropHint">Drag & drop an image here<br><span style="font-size: 14px; color: #666;">or click to choose a file</span></div>
</div>

<script>
// ------------------ WebGL Setup ------------------

const canvas = document.getElementById("glcanvas");
const gl = canvas.getContext("webgl2", { preserveDrawingBuffer: true, alpha: true });

if (!gl) {
    alert("WebGL2 not supported.");
}

// Enable transparency
gl.enable(gl.BLEND);
gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
gl.clearColor(0.0, 0.0, 0.0, 0.0);

// Vertex shader
const vsSource = `#version 300 es
precision highp float;

const vec2 verts[6] = vec2[6](
    vec2(-1.0, -1.0),
    vec2( 1.0, -1.0),
    vec2(-1.0,  1.0),
    vec2(-1.0,  1.0),
    vec2( 1.0, -1.0),
    vec2( 1.0,  1.0)
);

void main() {
    gl_Position = vec4(verts[gl_VertexID], 0.0, 1.0);
}
`;

// Fragment shader
const fsSource = `#version 300 es
precision highp float;

uniform sampler2D uTex;
uniform float uCurvature;
uniform float uScale;

out vec4 outColor;

vec2 parabolicDistort(vec2 uv, float curvature) {
    if(curvature <= 0.0) return uv;

    float x1 = uv.x * (uv.x - 1.0);
    float y1 = (uv.y * -2.0) + 1.0;

    float y2 = uv.y + (x1 * y1 * curvature);

    return clamp(vec2(uv.x, y2), 0.0, 1.0);
}

void main() {
    vec2 texSize = vec2(textureSize(uTex, 0));

    vec2 uv = gl_FragCoord.xy / texSize;
    uv.y = 1.0 - uv.y;

    // Apply scale around center (0.5, 0.5) FIRST - this zooms the source image
    // Invert scale so higher values zoom in (larger image)
    vec2 scaledUV = (uv - 0.5) / uScale + 0.5;

    // Then apply parabolic distortion to the scaled coordinates
    vec2 duv = parabolicDistort(scaledUV, uCurvature);
    
    outColor = texture(uTex, duv);
}

`;

// ------------------ Shader Compiler ------------------

function compileShader(src, type) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, src);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error(gl.getShaderInfoLog(shader));
        throw new Error("Shader compile error");
    }
    return shader;
}

const vs = compileShader(vsSource, gl.VERTEX_SHADER);
const fs = compileShader(fsSource, gl.FRAGMENT_SHADER);

const program = gl.createProgram();
gl.attachShader(program, vs);
gl.attachShader(program, fs);
gl.linkProgram(program);

if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    console.error(gl.getProgramInfoLog(program));
    throw new Error("Program link error");
}

gl.useProgram(program);

const uTexLoc = gl.getUniformLocation(program, "uTex");
const uCurvLoc = gl.getUniformLocation(program, "uCurvature");
const uScaleLoc = gl.getUniformLocation(program, "uScale");

gl.uniform1i(uTexLoc, 0);

// ------------------ Texture Handling ------------------

let texture = gl.createTexture();
gl.bindTexture(gl.TEXTURE_2D, texture);

gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);

gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

// Default placeholder
gl.texImage2D(
    gl.TEXTURE_2D,
    0,
    gl.RGBA,
    1, 1,
    0,
    gl.RGBA,
    gl.UNSIGNED_BYTE,
    new Uint8Array([255, 255, 255, 255])
);

// ------------------ Rendering ------------------

function render() {
    const curv = parseFloat(document.getElementById("curvNumber").value);
    const scale = parseFloat(document.getElementById("scaleNumber").value);
    gl.uniform1f(uCurvLoc, curv);
    gl.uniform1f(uScaleLoc, scale);
    
    // Clear with transparent background
    gl.clear(gl.COLOR_BUFFER_BIT);
    
    gl.drawArrays(gl.TRIANGLES, 0, 6);
}

function loadImage(img) {
    canvas.width = img.width;
    canvas.height = img.height;

    gl.viewport(0, 0, canvas.width, canvas.height);

    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texImage2D(
        gl.TEXTURE_2D,
        0,
        gl.RGBA,
        gl.RGBA,
        gl.UNSIGNED_BYTE,
        img
    );

    // Hide the drop hint once an image is loaded
    document.getElementById("dropHint").classList.add("hidden");

    // Show the controls once an image is loaded
    document.getElementById("curvatureRow").classList.remove("hidden");
    document.getElementById("scaleRow").classList.remove("hidden");
    document.getElementById("downloadBtn").classList.remove("hidden");

    render();
}

function loadImageFromFile(file) {
    if (!file || !file.type.startsWith('image/')) {
        return;
    }

    // Store the original filename
    currentFileName = file.name;

    const img = new Image();
    img.onload = () => loadImage(img);
    img.src = URL.createObjectURL(file);
}

// ------------------ UI Events ------------------

let currentFileName = null;

const slider = document.getElementById("curvature");
const number = document.getElementById("curvNumber");
const scaleSlider = document.getElementById("scale");
const scaleNumber = document.getElementById("scaleNumber");

function saveToLocalStorage() {
    localStorage.setItem('curvature', slider.value);
    localStorage.setItem('scale', scaleSlider.value);
}

function loadFromLocalStorage() {
    const savedCurvature = localStorage.getItem('curvature');
    const savedScale = localStorage.getItem('scale');
    
    if (savedCurvature !== null) {
        slider.value = savedCurvature;
        number.value = savedCurvature;
    }
    
    if (savedScale !== null) {
        scaleSlider.value = savedScale;
        scaleNumber.value = savedScale;
    }
}

function syncCurvature(val) {
    slider.value = val;
    number.value = val;
    saveToLocalStorage();
    render();
}

function syncScale(val) {
    scaleSlider.value = val;
    scaleNumber.value = val;
    saveToLocalStorage();
    render();
}

slider.addEventListener("input", () => syncCurvature(slider.value));
number.addEventListener("input", () => syncCurvature(number.value));
scaleSlider.addEventListener("input", () => syncScale(scaleSlider.value));
scaleNumber.addEventListener("input", () => syncScale(scaleNumber.value));

document.getElementById("fileInput").addEventListener("change", (e) => {
    const file = e.target.files[0];
    if (!file) return;
    loadImageFromFile(file);
});

// Drag and drop handlers
canvas.addEventListener("dragover", (e) => {
    e.preventDefault();
    e.stopPropagation();
    canvas.classList.add("drag-over");
});

canvas.addEventListener("dragenter", (e) => {
    e.preventDefault();
    e.stopPropagation();
    canvas.classList.add("drag-over");
});

canvas.addEventListener("dragleave", (e) => {
    e.preventDefault();
    e.stopPropagation();
    canvas.classList.remove("drag-over");
});

canvas.addEventListener("drop", (e) => {
    e.preventDefault();
    e.stopPropagation();
    canvas.classList.remove("drag-over");

    const file = e.dataTransfer.files[0];
    if (file) {
        loadImageFromFile(file);
    }
});

// Click handler for canvas to open file picker
const canvasContainer = document.querySelector(".canvas-container");
canvasContainer.addEventListener("click", () => {
    document.getElementById("fileInput").click();
});

document.getElementById("downloadBtn").addEventListener("click", () => {
    let downloadName = "distorted.png";
    
    if (currentFileName) {
        // Add "_distorted" suffix before the file extension
        const lastDot = currentFileName.lastIndexOf('.');
        if (lastDot !== -1) {
            const nameWithoutExt = currentFileName.substring(0, lastDot);
            const ext = currentFileName.substring(lastDot);
            downloadName = nameWithoutExt + "_distorted" + ext;
        } else {
            downloadName = currentFileName + "_distorted.png";
        }
    }
    
    const link = document.createElement("a");
    link.download = downloadName;
    link.href = canvas.toDataURL("image/png");
    link.click();
});

// Load saved values from localStorage
loadFromLocalStorage();

// initial render
render();

</script>

</body>
</html>
