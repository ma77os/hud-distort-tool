<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Parabolic HUD Distortion</title>
<style>
    body {
        margin: 0;
        background: #111;
        color: #eee;
        font-family: sans-serif;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 12px;
        padding: 20px;
    }
    canvas { 
        border: 1px solid #444;
        max-width: 90vw;
        max-height: 70vh;
        transition: border-color 0.2s;
    }
    canvas.drag-over {
        border-color: #0af;
        border-width: 2px;
    }
    .canvas-container {
        position: relative;
        display: inline-block;
    }
    .drop-hint {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: #888;
        font-size: 18px;
        pointer-events: none;
        text-align: center;
        transition: opacity 0.3s;
    }
    .drop-hint.hidden {
        opacity: 0;
    }
    .panel {
        display: flex;
        gap: 10px;
        align-items: center;
    }
    #curvNumber {
        width: 70px;
        background: #222;
        color: #eee;
        border: 1px solid #555;
        padding: 2px 4px;
    }
</style>
</head>
<body>

<h2>Parabolic Distortion Tool</h2>

<div class="panel">
    <input type="file" id="fileInput" accept="image/*">

    <label>Curvature</label>

    <input type="number" id="curvNumber" step="0.001" min="-0.5" max="0.5" value="-0.1">
    <input type="range" id="curvature" min="-0.5" max="0.5" step="0.001" value="-0.1">

    <button id="downloadBtn">Download PNG</button>
</div>

<div class="canvas-container">
    <canvas id="glcanvas" width="1024" height="512"></canvas>
    <div class="drop-hint" id="dropHint">Drag & drop an image here<br><span style="font-size: 14px; color: #666;">or use the file button above</span></div>
</div>

<script>
// ------------------ WebGL Setup ------------------

const canvas = document.getElementById("glcanvas");
const gl = canvas.getContext("webgl2", { preserveDrawingBuffer: true });

if (!gl) {
    alert("WebGL2 not supported.");
}

// Vertex shader
const vsSource = `#version 300 es
precision highp float;

const vec2 verts[6] = vec2[6](
    vec2(-1.0, -1.0),
    vec2( 1.0, -1.0),
    vec2(-1.0,  1.0),
    vec2(-1.0,  1.0),
    vec2( 1.0, -1.0),
    vec2( 1.0,  1.0)
);

void main() {
    gl_Position = vec4(verts[gl_VertexID], 0.0, 1.0);
}
`;

// Fragment shader with safe clamped UV sampling
const fsSource = `#version 300 es
precision highp float;

uniform sampler2D uTex;
uniform float uCurvature;

out vec4 outColor;

vec2 parabolicDistort(vec2 uv, float curvature) {
    vec2 p = uv - 0.5;
    float r2 = dot(p, p);
    vec2 p2 = p * (1.0 + curvature * r2);
    return p2 + 0.5;
}

void main() {
    vec2 texSize = vec2(textureSize(uTex, 0));

    vec2 uv = gl_FragCoord.xy / texSize;
    uv.y = 1.0 - uv.y;

    vec2 duv = parabolicDistort(uv, uCurvature);

    // proper vector clamp
    vec2 minUV = vec2(0.0, 0.0);
    vec2 maxUV = vec2(1.0) - vec2(1.0) / texSize;
    duv = clamp(duv, minUV, maxUV);

    outColor = texture(uTex, duv);
}

`;

// ------------------ Shader Compiler ------------------

function compileShader(src, type) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, src);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error(gl.getShaderInfoLog(shader));
        throw new Error("Shader compile error");
    }
    return shader;
}

const vs = compileShader(vsSource, gl.VERTEX_SHADER);
const fs = compileShader(fsSource, gl.FRAGMENT_SHADER);

const program = gl.createProgram();
gl.attachShader(program, vs);
gl.attachShader(program, fs);
gl.linkProgram(program);

if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    console.error(gl.getProgramInfoLog(program));
    throw new Error("Program link error");
}

gl.useProgram(program);

const uTexLoc = gl.getUniformLocation(program, "uTex");
const uCurvLoc = gl.getUniformLocation(program, "uCurvature");

gl.uniform1i(uTexLoc, 0);

// ------------------ Texture Handling ------------------

let texture = gl.createTexture();
gl.bindTexture(gl.TEXTURE_2D, texture);

gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);

gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

// Default placeholder
gl.texImage2D(
    gl.TEXTURE_2D,
    0,
    gl.RGBA,
    1, 1,
    0,
    gl.RGBA,
    gl.UNSIGNED_BYTE,
    new Uint8Array([255, 255, 255, 255])
);

// ------------------ Rendering ------------------

function render() {
    const curv = parseFloat(document.getElementById("curvNumber").value);
    gl.uniform1f(uCurvLoc, curv);
    gl.drawArrays(gl.TRIANGLES, 0, 6);
}

function loadImage(img) {
    canvas.width = img.width;
    canvas.height = img.height;

    gl.viewport(0, 0, canvas.width, canvas.height);

    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texImage2D(
        gl.TEXTURE_2D,
        0,
        gl.RGBA,
        gl.RGBA,
        gl.UNSIGNED_BYTE,
        img
    );

    // Hide the drop hint once an image is loaded
    document.getElementById("dropHint").classList.add("hidden");

    render();
}

function loadImageFromFile(file) {
    if (!file || !file.type.startsWith('image/')) {
        return;
    }

    // Store the original filename
    currentFileName = file.name;

    const img = new Image();
    img.onload = () => loadImage(img);
    img.src = URL.createObjectURL(file);
}

// ------------------ UI Events ------------------

let currentFileName = null;

const slider = document.getElementById("curvature");
const number = document.getElementById("curvNumber");

function syncCurvature(val) {
    slider.value = val;
    number.value = val;
    render();
}

slider.addEventListener("input", () => syncCurvature(slider.value));
number.addEventListener("input", () => syncCurvature(number.value));

document.getElementById("fileInput").addEventListener("change", (e) => {
    const file = e.target.files[0];
    if (!file) return;
    loadImageFromFile(file);
});

// Drag and drop handlers
canvas.addEventListener("dragover", (e) => {
    e.preventDefault();
    e.stopPropagation();
    canvas.classList.add("drag-over");
});

canvas.addEventListener("dragenter", (e) => {
    e.preventDefault();
    e.stopPropagation();
    canvas.classList.add("drag-over");
});

canvas.addEventListener("dragleave", (e) => {
    e.preventDefault();
    e.stopPropagation();
    canvas.classList.remove("drag-over");
});

canvas.addEventListener("drop", (e) => {
    e.preventDefault();
    e.stopPropagation();
    canvas.classList.remove("drag-over");

    const file = e.dataTransfer.files[0];
    if (file) {
        loadImageFromFile(file);
    }
});

document.getElementById("downloadBtn").addEventListener("click", () => {
    let downloadName = "distorted.png";
    
    if (currentFileName) {
        // Add "_distorted" suffix before the file extension
        const lastDot = currentFileName.lastIndexOf('.');
        if (lastDot !== -1) {
            const nameWithoutExt = currentFileName.substring(0, lastDot);
            const ext = currentFileName.substring(lastDot);
            downloadName = nameWithoutExt + "_distorted" + ext;
        } else {
            downloadName = currentFileName + "_distorted.png";
        }
    }
    
    const link = document.createElement("a");
    link.download = downloadName;
    link.href = canvas.toDataURL("image/png");
    link.click();
});

// initial render
render();

</script>

</body>
</html>
