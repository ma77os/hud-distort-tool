<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Parabolic HUD Distortion</title>
<style>
    body {
        margin: 0;
        background: #111;
        color: #eee;
        font-family: sans-serif;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 12px;
        padding: 20px;
    }
    canvas { 
        border: 1px solid #444;
        max-width: 90vw;
        max-height: 70vh;
    }
    .panel {
        display: flex;
        gap: 10px;
        align-items: center;
    }
    #curvNumber {
        width: 70px;
        background: #222;
        color: #eee;
        border: 1px solid #555;
        padding: 2px 4px;
    }
</style>
</head>
<body>

<h2>Parabolic Distortion Tool</h2>

<div class="panel">
    <input type="file" id="fileInput" accept="image/*">

    <label>Curvature</label>

    <input type="number" id="curvNumber" step="0.001" min="-0.5" max="0.5" value="-0.1">
    <input type="range" id="curvature" min="-0.5" max="0.5" step="0.001" value="-0.1">

    <button id="downloadBtn">Download PNG</button>
</div>

<canvas id="glcanvas" width="1024" height="512"></canvas>

<script>
// ------------------ WebGL Setup ------------------

const canvas = document.getElementById("glcanvas");
const gl = canvas.getContext("webgl2", { preserveDrawingBuffer: true });

if (!gl) {
    alert("WebGL2 not supported.");
}

// Vertex shader
const vsSource = `#version 300 es
precision highp float;

const vec2 verts[6] = vec2[6](
    vec2(-1.0, -1.0),
    vec2( 1.0, -1.0),
    vec2(-1.0,  1.0),
    vec2(-1.0,  1.0),
    vec2( 1.0, -1.0),
    vec2( 1.0,  1.0)
);

void main() {
    gl_Position = vec4(verts[gl_VertexID], 0.0, 1.0);
}
`;

// Fragment shader with safe clamped UV sampling
const fsSource = `#version 300 es
precision highp float;

uniform sampler2D uTex;
uniform float uCurvature;

out vec4 outColor;

vec2 parabolicDistort(vec2 uv, float curvature) {
    vec2 p = uv - 0.5;
    float r2 = dot(p, p);
    vec2 p2 = p * (1.0 + curvature * r2);
    return p2 + 0.5;
}

void main() {
    vec2 texSize = vec2(textureSize(uTex, 0));

    vec2 uv = gl_FragCoord.xy / texSize;
    uv.y = 1.0 - uv.y;

    vec2 duv = parabolicDistort(uv, uCurvature);

    // proper vector clamp
    vec2 minUV = vec2(0.0, 0.0);
    vec2 maxUV = vec2(1.0) - vec2(1.0) / texSize;
    duv = clamp(duv, minUV, maxUV);

    outColor = texture(uTex, duv);
}

`;

// ------------------ Shader Compiler ------------------

function compileShader(src, type) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, src);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error(gl.getShaderInfoLog(shader));
        throw new Error("Shader compile error");
    }
    return shader;
}

const vs = compileShader(vsSource, gl.VERTEX_SHADER);
const fs = compileShader(fsSource, gl.FRAGMENT_SHADER);

const program = gl.createProgram();
gl.attachShader(program, vs);
gl.attachShader(program, fs);
gl.linkProgram(program);

if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    console.error(gl.getProgramInfoLog(program));
    throw new Error("Program link error");
}

gl.useProgram(program);

const uTexLoc = gl.getUniformLocation(program, "uTex");
const uCurvLoc = gl.getUniformLocation(program, "uCurvature");

gl.uniform1i(uTexLoc, 0);

// ------------------ Texture Handling ------------------

let texture = gl.createTexture();
gl.bindTexture(gl.TEXTURE_2D, texture);

gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);

gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

// Default placeholder
gl.texImage2D(
    gl.TEXTURE_2D,
    0,
    gl.RGBA,
    1, 1,
    0,
    gl.RGBA,
    gl.UNSIGNED_BYTE,
    new Uint8Array([255, 255, 255, 255])
);

// ------------------ Rendering ------------------

function render() {
    const curv = parseFloat(document.getElementById("curvNumber").value);
    gl.uniform1f(uCurvLoc, curv);
    gl.drawArrays(gl.TRIANGLES, 0, 6);
}

function loadImage(img) {
    canvas.width = img.width;
    canvas.height = img.height;

    gl.viewport(0, 0, canvas.width, canvas.height);

    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texImage2D(
        gl.TEXTURE_2D,
        0,
        gl.RGBA,
        gl.RGBA,
        gl.UNSIGNED_BYTE,
        img
    );

    render();
}

// ------------------ UI Events ------------------

const slider = document.getElementById("curvature");
const number = document.getElementById("curvNumber");

function syncCurvature(val) {
    slider.value = val;
    number.value = val;
    render();
}

slider.addEventListener("input", () => syncCurvature(slider.value));
number.addEventListener("input", () => syncCurvature(number.value));

document.getElementById("fileInput").addEventListener("change", (e) => {
    const file = e.target.files[0];
    if (!file) return;

    const img = new Image();
    img.onload = () => loadImage(img);
    img.src = URL.createObjectURL(file);
});

document.getElementById("downloadBtn").addEventListener("click", () => {
    const link = document.createElement("a");
    link.download = "distorted.png";
    link.href = canvas.toDataURL("image/png");
    link.click();
});

// initial render
render();

</script>

</body>
</html>
